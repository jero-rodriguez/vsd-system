export class VsDCharacter extends Actor {
  /** @override */
  prepareData() {
    // Prepare data for the actor. Calling the super version of this executes
    // the following, in order: data reset (to clear active effects),
    // prepareBaseData(), prepareEmbeddedDocuments() (including active effects),
    // prepareDerivedData().
    super.prepareData();
  }

  /** @override */
  prepareBaseData() {
    // Data modifications in this step occur before processing embedded
    // documents or derived data.
  }

  getRankBonus(ranks) {
    ranks = Math.max(0, Math.floor(Number(ranks) || 0));

    const firstTier = Math.min(ranks, 10); // 1–10 → +5
    const secondTier = Math.max(Math.min(ranks, 20) - 10, 0); // 11–20 → +2
    const thirdTier = Math.max(ranks - 20, 0); // 21+ → +1

    return 5 * firstTier + 2 * secondTier + thirdTier;
  }

  /**
   * @override
   * Augment the actor source data with additional dynamic data that isn't
   * handled by the actor's DataModel. Data calculated in this step should be
   * available both inside and outside of character sheets (such as if an actor
   * is queried and has a roll executed directly from it).
   */
  prepareDerivedData() {
    super.prepareDerivedData();

    const system = this.system;
    if (!system) return;

    const stats = system.stats;
    if (!stats) return;

    const skills = system.skills;
    if (!skills) return;

    // 1) Stats
    if (stats) {
      for (const [key, stat] of Object.entries(stats)) {
        const base = Number(stat.base) || 0;
        const kin = Number(stat.kin) || 0;
        const spec = Number(stat.spec) || 0;
        stat.total = base + kin + spec;
      }
    }

    // 2) Skills
    if (skills) {
      for (const category of Object.values(skills)) {
        if (!category?.skills) continue;

        for (const skill of Object.values(category.skills)) {
          const ranks = Number(skill.ranks) || 0;
          const rankBonus = this.getRankBonus(ranks);
          skill.rankBonus = rankBonus;

          const voc = Number(skill.voc) || 0;
          const kin = Number(skill.kin) || 0;
          const spec = Number(skill.spec) || 0;
          const item = Number(skill.item) || 0;

          skill.total = rankBonus + voc + kin + spec + item;
        }
      }
    }

    // 3) Spell Lores
    const spellLores = system.spellLores ?? [];
    for (const lore of spellLores) {
      if (!lore) continue;

      const ranks = Number(lore.ranks) || 0;
      const rankBonus = this.getRankBonus(ranks);
      lore.rankBonus = rankBonus;

      const voc = Number(lore.voc) || 0;
      const kin = Number(lore.kin) || 0;
      const spec = Number(lore.spec) || 0;
      const item = Number(lore.item) || 0;

      lore.total = rankBonus + voc + kin + spec + item;
    }

    // 4) Inventory summary (de momento solo inicializamos; más adelante,
    // cuando definamos Items, sumaremos pesos aquí con this.items)
    if (!system.encumbrance) {
      system.encumbrance = {};
    }
    system.encumbrance.carriedWeight =
      Number(system.encumbrance.carriedWeight) || 0;
    system.encumbrance.maxWeight = Number(system.encumbrance.maxWeight) || 0;
    system.encumbrance.penalty = Number(system.encumbrance.penalty) || 0;
  }

  getRollData2() {
    const data = super.getRollData ? super.getRollData() : {};
    // Si quieres exponer cosas de system para fórmulas, las añades aquí
    return data;
  }

  /**
   *
   * @override
   * Augment the actor's default getRollData() method by appending the data object
   * generated by the its DataModel's getRollData(), or null. This polymorphic
   * approach is useful when you have actors & items that share a parent Document,
   * but have slightly different data preparation needs.
   */
  getRollData() {
    return { ...super.getRollData(), ...(this.system.getRollData?.() ?? null) };
  }

  /**
   * Convert the actor document to a plain object.
   *
   * The built in `toObject()` method will ignore derived data when using Data Models.
   * This additional method will instead use the spread operator to return a simplified
   * version of the data.
   *
   * @returns {object} Plain object either via deepClone or the spread operator.
   */
  toPlainObject() {
    const result = { ...this };

    // Simplify system data.
    result.system = this.system.toPlainObject();

    // Add items.
    result.items = this.items?.size > 0 ? this.items.contents : [];

    // Add effects.
    result.effects = this.effects?.size > 0 ? this.effects.contents : [];

    return result;
  }
}
